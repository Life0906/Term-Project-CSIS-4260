# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H0wOdjP1NDvhgFybdvnW-JEoJBm5Ndi3
"""

# streamlit_app.py
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping

# Load live BTC data from Yahoo Finance
def load_data():
    btc = yf.Ticker("BTC-USD")
    df = btc.history(period="10y", interval="1d")
    df = df.drop(columns=['Dividends', 'Stock Splits'])
    df['Daily_Return'] = df['Close'].pct_change().fillna(0)
    df['Volatility_7d'] = df['Close'].rolling(window=7).std().fillna(method='bfill')
    df['Relative_Volume'] = df['Volume'] / df['Volume'].rolling(window=20).mean().fillna(method='bfill')
    df = df.dropna()
    return df

# Create sequences for LSTM with lookback
def create_sequences(X, y, lookback):
    X_seq, y_seq = [], []
    for i in range(len(X) - lookback):
        X_seq.append(X[i:i + lookback])
        y_seq.append(y[i + lookback])
    return np.array(X_seq), np.array(y_seq)

# Train a model with given config
def train_lstm(df, lookback, scale_y=False):
    X = df.drop(columns=['Close'])
    y = df['Close']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.005, shuffle=False)
    X_train = X_train[:-1]
    y_train = y_train[1:]
    X_test = X_test[:-1]
    y_test = y_test[1:]

    scaler_X = MinMaxScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)

    if scale_y:
        scaler_y = MinMaxScaler()
        y_train_scaled = scaler_y.fit_transform(y_train.values.reshape(-1, 1))
        y_test_scaled = scaler_y.transform(y_test.values.reshape(-1, 1))
        y_train_final = y_train_scaled
        y_test_final = y_test_scaled
    else:
        scaler_y = None
        y_train_final = y_train.values
        y_test_final = y_test.values

    if lookback == 1:
        X_train_final = X_train_scaled.reshape((X_train_scaled.shape[0], 1, X_train_scaled.shape[1]))
        X_test_final = X_test_scaled.reshape((X_test_scaled.shape[0], 1, X_test_scaled.shape[1]))
    else:
        X_train_final, y_train_final = create_sequences(X_train_scaled, y_train_final, lookback)
        X_test_final, y_test_final = create_sequences(X_test_scaled, y_test_final, lookback)

    model = Sequential()
    model.add(LSTM(50, activation='relu', return_sequences=True, input_shape=(lookback, X_train_final.shape[2])))
    model.add(Dropout(0.2))
    model.add(LSTM(25, activation='relu'))
    model.add(Dropout(0.2))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')

    early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
    X_train_split, X_val, y_train_split, y_val = train_test_split(X_train_final, y_train_final, test_size=0.2, shuffle=False)

    model.fit(X_train_split, y_train_split, validation_data=(X_val, y_val), epochs=200, batch_size=32, callbacks=[early_stopping], verbose=0)

    y_pred = model.predict(X_test_final)
    r2 = r2_score(y_test_final, y_pred)

    return model, r2, scaler_X, scaler_y, X, df

# Predict next 5 days

def predict_next_days(model, scaler_X, scaler_y, X, lookback, scale_y):
    future_days = 5
    future_preds = []
    last_seq = X[-lookback:].copy()
    current_seq = scaler_X.transform(last_seq).reshape(1, lookback, X.shape[1])

    for _ in range(future_days):
        pred_scaled = model.predict(current_seq)[0][0]
        future_preds.append(pred_scaled)

        # Build next row using last known values
        new_row = last_seq.iloc[-1].copy()
        last_seq = pd.concat([last_seq, pd.DataFrame([new_row])])
        last_seq = last_seq.iloc[1:]
        current_seq = scaler_X.transform(last_seq).reshape(1, lookback, X.shape[1])

    if scale_y:
        future_preds = scaler_y.inverse_transform(np.array(future_preds).reshape(-1, 1)).flatten()

    last_date = X.index[-1]
    future_dates = [last_date + pd.Timedelta(days=i+1) for i in range(future_days)]
    return future_dates, future_preds

# --- Streamlit App ---
st.set_page_config(page_title="Bitcoin Price Predictor", layout="wide")
st.title("üìà Bitcoin Price Prediction using LSTM")

model_option = st.selectbox("Choose an LSTM Model:", (
    "1-Day Lookback (y scaled)",
    "7-Day Lookback (y unscaled)",
    "5-Day Lookback (y unscaled)"
))

with st.spinner("Loading and training model..."):
    df = load_data()
    lookback = 1 if "1-Day" in model_option else (7 if "7-Day" in model_option else 5)
    scale_y = True if "scaled" in model_option else False
    model, r2, scaler_X, scaler_y, X, df = train_lstm(df, lookback, scale_y)
    future_dates, future_preds = predict_next_days(model, scaler_X, scaler_y, X, lookback, scale_y)

# Show R^2 Score
st.metric("Model R¬≤ Score", f"{r2:.4f}")

# Plot
fig, ax = plt.subplots(figsize=(12, 5))
ax.plot(df.index, df['Close'], label='Actual Price', color='blue')
ax.plot(future_dates, future_preds, label='Predicted Price', linestyle='--', marker='o', color='orange')
ax.set_title("Bitcoin Price Prediction")
ax.set_xlabel("Date")
ax.set_ylabel("Price (USD)")
ax.legend()
ax.grid(True)
st.pyplot(fig)

# Footer
st.markdown("---")
st.markdown("Built with ‚ù§Ô∏è by Arsh Gupta")